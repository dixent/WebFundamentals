project_path: /web/fundamentals/_project.yaml book_path: /web/fundamentals/_book.yaml описание: архитектура оболочки приложения поддерживает локальный пользовательский интерфейс и динамически загружает контент, не жертвуя связностью и обнаруживаемостью в Интернете.

{# wf_updated_on: 2019-05-02 #} {# wf_published_on: 2016-09-27 #} {# wf_blink_components: N / A #}

# Модель оболочки приложения {: .page-title}

{% include "web / _shared / contributors / addyosmani.html"%}

Архитектура **оболочки приложения** (или оболочки приложения) - это один из способов создания Progressive Web App, которое надежно и мгновенно загружается на экраны ваших пользователей, подобно тому, что вы видите в нативных приложениях.

«Оболочка» приложения - это минимальный HTML, CSS и JavaScript, необходимый для обеспечения работы пользовательского интерфейса, а при кэшировании в автономном режиме может обеспечить **мгновенную, надежно хорошую производительность** для пользователей при повторных посещениях. Это означает, что оболочка приложения не загружается из сети каждый раз, когда пользователь посещает. Из сети требуется только необходимый контент.

Для [одностраничных приложений](https://en.wikipedia.org/wiki/Single-page_application) с архитектурой, насыщенной JavaScript, подходящей является оболочка приложения. Этот подход основан на агрессивном кэшировании оболочки (с использованием [сервисного работника](/web/fundamentals/primers/service-worker/) ) для запуска приложения. Затем динамический контент загружается для каждой страницы с использованием JavaScript. Оболочка приложения полезна для быстрого вывода начального HTML на экран без сети.

<img src="../../../../en/fundamentals/architecture/images/appshell.png" alt="Application Shell architecture">

Иными словами, оболочка приложения похожа на пакет кода, который вы публикуете в магазине приложений при создании собственного приложения. Это каркас вашего пользовательского интерфейса и основные компоненты, необходимые для запуска вашего приложения с нуля, но, скорее всего, они не содержат данных.

Примечание. Попробуйте кодовую метку [First Progressive Web App,](https://codelabs.developers.google.com/codelabs/your-first-pwapp/#0) чтобы узнать, как спроектировать архитектуру и внедрить первую оболочку приложения для приложения погоды. [Мгновенная загрузка с моделью App App](https://www.youtube.com/watch?v=QhUzmR8eZAo) также проходит через этот паттерн.

### Когда использовать модель оболочки приложения

Создание PWA не означает начинать с нуля. Если вы создаете современное одностраничное приложение, то вы, вероятно, уже используете что-то похожее на оболочку приложения, независимо от того, назовете ли вы это так или нет. Детали могут немного отличаться в зависимости от того, какие библиотеки или фреймворки вы используете, но сама концепция не зависит от фреймворка.

Архитектура оболочки приложения наиболее удобна для приложений и сайтов с относительно неизменной навигацией, но с изменением контента. Ряд современных фреймворков и библиотек JavaScript уже поощряют отделение логики вашего приложения от его содержимого, что делает эту архитектуру более простой в применении. Для определенного класса веб-сайтов, имеющих только статический контент, вы все равно можете следовать той же модели, но сайт на 100% является оболочкой приложения.

Чтобы увидеть, как Google создал архитектуру оболочки приложения, взгляните на [Построение прогрессивного веб-приложения Google I / O 2016](/web/showcase/2016/iowa2016) . Это реальное приложение началось с SPA, чтобы создать PWA, который осуществляет предварительный кеширование контента с помощью работника службы, динамически загружает новые страницы, изящно переключается между представлениями и повторно использует контент после первой загрузки.

### Преимущества {: # app-shell-выгоды}

Преимущества архитектуры оболочки приложения с работником службы включают в себя:

- **Надежная работа, которая неизменно быстрая** . Повторные посещения очень быстрые. Статические ресурсы и пользовательский интерфейс (например, HTML, JavaScript, изображения и CSS) кэшируются при первом посещении, поэтому они мгновенно загружаются при повторных посещениях. Контент *может* кэшироваться при первом посещении, но обычно загружается, когда это необходимо.

- **Нативоподобные взаимодействия** . Приняв модель оболочки приложения, вы можете создавать впечатления с мгновенной навигацией и взаимодействием, аналогичными встроенному в приложение, с автономной поддержкой.

- **Экономное использование данных** . Разработайте для минимального использования данных и будьте осмотрительны в том, что вы кешируете, поскольку перечисление несущественных файлов (например, больших изображений, которые не отображаются на каждой странице) приводит к тому, что браузеры загружают больше данных, чем это строго необходимо. Хотя в западных странах данные относительно дешевы, это не относится к развивающимся рынкам, где возможности подключения дорогостоящие, а данные дорогостоящие.

## Требования {: # app-shell-требования}

Оболочка приложения в идеале должна:

- Быстрая загрузка
- Используйте как можно меньше данных
- Используйте статические ресурсы из локального кэша
- Отделить контент от навигации
- Извлекать и отображать содержимое страницы (HTML, JSON и т. Д.)
- Опционально, кешировать динамический контент

Оболочка приложения поддерживает локальный пользовательский интерфейс и динамически загружает контент через API, но не жертвует связью и открываемостью в Интернете. В следующий раз, когда пользователь получит доступ к вашему приложению, автоматически отобразится последняя версия. Нет необходимости загружать новые версии перед использованием.

Примечание. Расширение аудита [Lighthouse](https://github.com/googlechrome/lighthouse) можно использовать для проверки того, достигает ли ваш PWA, использующий оболочку приложения, высокий показатель производительности. [Для Маяка](https://www.youtube.com/watch?v=LZjQ25NRV-E) это разговор, который идет через оптимизацию PWA с помощью этого инструмента.

## Сборка оболочки вашего приложения {: # building-your-app-shell}

Структурируйте свое приложение для четкого различия между оболочкой страницы и динамическим контентом. В общем, ваше приложение должно загружать простейшую из возможных оболочек, но при первоначальной загрузке включать достаточно содержательного содержимого страницы. Определите правильный баланс между скоростью и свежестью данных для каждого из ваших источников данных.

<figure>
  <img src="../../../../en/fundamentals/architecture/images/wikipedia.jpg" alt="Offline Wikipedia app using an application shell with content caching">
  <figcaption><a href="https://wiki-offline.jakearchibald.com/wiki/Rick_and_Morty">Автономное приложение Википедии</a> Джейка Арчибальда является хорошим примером PWA, который использует модель оболочки приложения. Он загружается мгновенно при повторных посещениях, но динамически выбирает контент, используя JS. Этот контент затем кэшируется в автономном режиме для будущих посещений.</figcaption>
</figure>

### Пример HTML для оболочки приложения {: # example-html-for-appshell}

Этот пример отделяет основную инфраструктуру приложения и пользовательский интерфейс от данных. Важно максимально упростить начальную загрузку, чтобы отображать только макет страницы сразу после открытия веб-приложения. Некоторые из них поступают из индексного файла вашего приложения (встроенный DOM, стили), а остальные загружаются из внешних скриптов и таблиц стилей.

Весь пользовательский интерфейс и инфраструктура кэшируются локально с помощью работника сервиса, так что при последующих загрузках извлекаются только новые или измененные данные вместо того, чтобы загружать все.

Ваш файл `index.html` в вашей рабочей директории должен выглядеть примерно так: Это подмножество фактического содержимого и не полный индексный файл. Давайте посмотрим, что в нем содержится.

- HTML и CSS для «скелета» вашего пользовательского интерфейса с заполнителями для навигации и содержимого.
- Внешний файл JavaScript (app.js) для обработки навигации и логики пользовательского интерфейса, а также кода для отображения сообщений, полученных с сервера, и их локального хранения с использованием механизма хранения, такого как IndexedDB.
- Манифест веб-приложения и служебный загрузчик для включения автономных возможностей.

<div class="clearfix"></div>

```
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>App Shell</title>
  <link rel="manifest" href="/manifest.json">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="styles/inline.css">
</head>

<body>
  <header class="header">
    <h1 class="header__title">App Shell</h1>
  </header>

  <nav class="nav">
  ...
  </nav>

  <main class="main">
  ...
  </main>

  <div class="dialog-container">
  ...
  </div>

  <div class="loader">
    <!-- Show a spinner or placeholders for content -->
  </div>

  <script src="app.js" async></script>
  <script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').then(function(registration) {
      // Registration was successful
      console.log('ServiceWorker registration successful with scope: ', registration.scope);
    }).catch(function(err) {
      // registration failed :(
      console.log('ServiceWorker registration failed: ', err);
    });
  }
  </script>
</body>
</html>
```

<div class="clearfix"></div>

Примечание. Подробнее об использовании оболочки приложения и рендеринга на стороне сервера для содержимого см. В [вашем первом прогрессивном веб-приложении](/web/fundamentals/codelabs/your-first-pwapp/) . Оболочка приложения может быть реализована с использованием любой библиотеки или фреймворка, как описано в наших <a href="https://www.youtube.com/watch?v=srdKq0DckXQ">Прогрессивных веб-приложениях во всех</a> обсуждениях <a href="https://www.youtube.com/watch?v=srdKq0DckXQ">фреймворка</a> Образцы доступны с использованием Polymer ( <a href="https://shop.polymer-project.org">Магазин</a> ) и React ( <a href="https://github.com/insin/react-hn">ReactHN</a> , <a href="https://github.com/GoogleChrome/sw-precache/tree/master/app-shell-demo">iFixit</a> ).

### Кэширование оболочки приложения {: # app-shell-caching}

Оболочка приложения может быть кэширована с помощью написанного вручную сервисного работника или сгенерированного сервисного работника с использованием инструмента статического [предварительного кэширования](https://github.com/googlechrome/sw-precache) активов, такого как [sw-precache](https://github.com/googlechrome/sw-precache) .

Примечание. Примеры приведены только для общей информации и в качестве иллюстрации. Фактические используемые ресурсы, вероятно, будут отличаться для вашего приложения.

#### Кэширование оболочки приложения вручную

Ниже приведен пример кода работника службы, который кэширует статические ресурсы из оболочки приложения в [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) с помощью события `install` работника службы:

```
var cacheName = 'shell-content';
var filesToCache = [
  '/css/styles.css',
  '/js/scripts.js',
  '/images/logo.svg',

  '/offline.html',

  '/',
];

self.addEventListener('install', function(e) {
  console.log('[ServiceWorker] Install');
  e.waitUntil(
    caches.open(cacheName).then(function(cache) {
      console.log('[ServiceWorker] Caching app shell');
      return cache.addAll(filesToCache);
    })
  );
});
```

#### Использование sw-precache для кэширования оболочки приложения

Работник службы, созданный с помощью sw-precache, будет кешировать и обслуживать ресурсы, которые вы настраиваете как часть процесса сборки. Вы можете использовать его для предварительного кэширования каждого файла HTML, JavaScript и CSS, который составляет оболочку вашего приложения. Все будет работать в автономном режиме и быстро загружаться при последующих посещениях без каких-либо дополнительных усилий.

Вот базовый пример использования sw-precache как части процесса сборки [gulp](http://gulpjs.com) :

```
gulp.task('generate-service-worker', function(callback) {
  var path = require('path');
  var swPrecache = require('sw-precache');
  var rootDir = 'app';

  swPrecache.write(path.join(rootDir, 'service-worker.js'), {
    staticFileGlobs: [rootDir + '/**/*.{js,html,css,png,jpg,gif}'],
    stripPrefix: rootDir
  }, callback);
});
```

Чтобы узнать больше о статическом кэшировании ресурсов, см. [Добавление сервисного работника с](https://codelabs.developers.google.com/codelabs/sw-precache/index.html?index=..%2F..%2Findex#0) кодовой меткой [sw-](https://codelabs.developers.google.com/codelabs/sw-precache/index.html?index=..%2F..%2Findex#0) precache.

Примечание: sw-precache полезен для автономного кэширования ваших статических ресурсов. Для динамических / динамических ресурсов мы рекомендуем использовать нашу бесплатную библиотеку [sw-toolbox](https://github.com/googlechrome/sw-toolbox) .

## Заключение {: #conclusion}

Оболочка приложения, использующая Service worker, является мощным шаблоном для автономного кэширования, но она также предлагает значительные выигрыши в производительности в виде мгновенной загрузки для повторных посещений вашего PWA. Вы можете кэшировать оболочку приложения, чтобы она работала в автономном режиме, и заполнять ее содержимое с помощью JavaScript.

При повторных посещениях это позволяет получать значимые пиксели на экране без сети, даже если ваш контент в конечном итоге поступает оттуда.

## Обратная связь {: #feedback}

{% include "web / _shared / полезно.html"%}
